---
title: "Selecting model cell lines for studying the phosphorylation signature of signaling pathways"
output:
  html_document:
    df_print: paged
---

This is the modified version of the original analysis. We applied for an R01 for studying the signature of phosphorylation pathway using the Kinobeads (Golkowski et al. 2017. JPR). We hope to find the specific phosphorylation pattern for a given signal pathway. For example, based on the RNA-seq data from CCLE and TCGA, FGFR and EGFR are often co-expressed, and in fact, a lot of the phosphorylation events are common between these two pathways. So can we deconvolute them using Kinobeads? 

In the first version of this R01 application, we were criticized by choosing the model cell lines arbitrarily. To solve this, I analyzed the CCLE RNA expression data and chose cell lines based on their expression level of the pathway components. The pathway information was drawn from the reactome.org. The script can be found in https://github.com/ht-lau/cells_for_pathway_analysis



In the previous script, I determined that the sums normalized expression gene expression from each signaling pathway is probably the easiest way to choose what cell lines to use. The outliner cell lines can be identified using the box plot. Basically, the cell lines with a sum expression value higher than 75% quantile + 1.5 * IQR. 

Followings are the signaling pathways chosen. Any pathways labeled as NA is not found in Reactome, but is in the original R01 proposal. These pathways are labeled as "Reactome".

EGF: Signal Transduction, Signaling by RTKs, Signaling by EGFR
FGF: Signal Transduction, Signaling by RTKs, Signaling by FGFR
HGF: Signal Transduction, Signaling by RTKs, Signaling by MET
TGFb: Signal Transduction, Signaling by TGF-beta, Signaling by TGF-beta receptor
IL6: Immune Sys, Cytokine Signaling, Signaling by IL, IL-6
WNTs: Signal Transduction, Signaling by WNT, TCF dependent signaling in response to WNT
SHH: Signal Transduction, Signaling by Hedgehog
Estrogen: Signal Transduction, Signaling by NR, ESR-mediated signaling
Glucose: Signal Transduction, Signaling by RTK, Signaling by Insulin receptor
Oxygen: Cell. responses to ext. stimuli, Cell. response to stress, hypoxia
PPMs/ECM: Extracellular matrix organization, Integrin cell surface interactions

The oncogenic pathways from Sanchez-Vega et. al. (2018) (PMID: 29625050) were also included in this version of the report. These are labeled as "TCGA"


Note 03/04/2019: we got the R01, the money is smaller than we asked for because of a budget cut (?). At least the lab can survive... Anyways, in the original version of this script, I did not check whether the receptors/essential components are expressed. I do actually know that some cells with high pathway expression level do not have the, say, EGFR expressed. So this version will fix this problem.

```{r packages, message=FALSE, echo=FALSE}
library(tidyverse)
library(ggthemes)
library(ggpubr)
library(readxl)
library(writexl)
library(qdapTools)  # required to turn the gene.list into df, list2df()
library(VennDiagram)
library(colorRamps)
library(RColorBrewer)
library(gplots)
```

```{r reactome gene list + TCGA oncogenes, echo=FALSE}
########
# can skip, if I am doing the same thing, there is a break point at 
# {r match the signaling component and calculate the sum of expressions}
########


# this part deal with the data I downloaded from the Reactome.
# Mainly, I want to extract the genes involved in each pathway.
# This will produce a list that I can use to match with the CCLE expression data

# There is also a paper published from TCGA looking at the 


# read the files containing the signaling components into a list
signaling.files <- list.files(path = "signaling_genes", pattern = "by_",
                              full.names = TRUE)            # full name extract the path

# use the file list created above to read the files into a list of df
# this dfs contain the data from reactome, which have to clean up further to extract the genes
gene.list <- lapply(signaling.files, read.delim, header = TRUE, stringsAsFactors = FALSE)

# extract the pathway names from the file list
pathway.names <- lapply(signaling.files, str_sub, 20, -5)

# add pathway names back to the file list
names(gene.list) <- pathway.names


############################################################
# The gene.list contains a lot of information that I don't need from the Reactome.
# So write a function to clean it up.
############################################################

extract.genes <- function(x, MoleculeType, MoleculeName) {
  x <- x %>% 
    filter(MoleculeType == "Proteins") %>% 
    separate(MoleculeName, into = c("Uniprot", "Gene.names"), sep = " ")
  x <- x[!duplicated(x$Gene.names), ]
  x <- x$Gene.names
}

# clean up the gene list with the new function
gene.list <- lapply(gene.list, FUN = extract.genes)
names(gene.list) <- str_c("Reactome.", names(gene.list))


# check the common set between RTKs
RTK <- gene.list[c("Reactome.EGFR", "Reactome.FGFR", "Reactome.Insulin_receptor")]

EGFR.WNT <- gene.list[c("Reactome.EGFR", "Reactome.TCF_Wnt")]

x <- gene.list$Reactome.TCF_Wnt[gene.list$Reactome.TCF_Wnt %in% gene.list$Reactome.EGFR]
y <- gene.list$Reactome.EGFR[gene.list$Reactome.EGFR %in% gene.list$Reactome.TCF_Wnt]
z <- gene.list$Reactome.EGFR[gene.list$Reactome.EGFR %in% gene.list$Reactome.FGFR]
```


```{r this is the TCGA list, echo=FALSE}

################################################################
# import of the TCGA data
################################################################

# an excel sheet, I only need the column 1 and 2, which are the pathways and genes, respectively 
SanchezVega <- read_excel("FigS3_SanchezVega_Cell.xlsx", sheet = "Pathways") %>%
  select(1:2)

# make a vectors containing the name of the pathways
SanchezVega.pathways <- SanchezVega$Pathway[!duplicated(SanchezVega$Pathway)]

# i want to create a list of vector containing the pathway components
tcga.gene.list <- list() # make an empty list 1st
for (n in 1:length(SanchezVega.pathways)) {
  tcga.gene.list[[n]] <- SanchezVega$Gene[SanchezVega$Pathway == SanchezVega.pathways[n]]
}
names(tcga.gene.list) <- str_c("TCGA.", SanchezVega.pathways)

##########################
# combine the TCGA and Reactome list
##########################

gene.list <- c(gene.list, tcga.gene.list)
```

There are 1326 genes in total (with duplcations) or 940 (without duplication). Among these, the TCGA data contains 310 (309) genes and Reactome contains 1016 (736 unique) genes. With 105 common genes.
```{r plotting the pathways, echo=FALSE}

gene.list.long <- list2df(gene.list)
names(gene.list.long)[1:2] <- c("Gene.names", "Pathways")
gene.list.long <- gene.list.long %>% separate(Pathways, into = c("Sources", "Pathways"), sep = "\\.")

ggplot(gene.list.long) +
  geom_bar(mapping = aes(x = Pathways)) +
  facet_wrap(~ Sources) +
  theme(axis.text.x = element_text(angle = 60, hjust = 1),
        panel.background = element_rect(fill = "white", colour = "grey50"))

Reactome.vs.TCGA <- ggplot(gene.list.long) +
  geom_bar(mapping = aes(x = Pathways)) +
  facet_wrap(~ Sources) +
  theme(axis.text.x = element_text(angle = 60, hjust = 1),
        panel.background = element_rect(fill = "white", colour = "grey50"))

# see how many of the TCGA genes are actually covered in the Reactome

tcga.genes <- gene.list.long$Gene.names[gene.list.long$Sources == "TCGA"]
sum(!duplicated(tcga.genes))

reactome.genes <- gene.list.long$Gene.names[gene.list.long$Sources == "Reactome"]
sum(!duplicated(reactome.genes))

x <- calculate.overlap(list(tcga.genes, reactome.genes))

sum(reactome.genes %in% tcga.genes)
sum(tcga.genes %in% reactome.genes)
```

```{r match the signaling component and calculate the sum of expressions, echo=FALSE}
########
# this part save the output, so I don't have to re-load the big data frame again
########

# import the previously produced normalized CCLE expression data
nor.ccle <- read.delim("Normalized_CCLE_RNAseq.txt", header = TRUE, stringsAsFactors = FALSE)


# create a new list to whole the list of df with pathway component expression values
ccle.pathways <- list()

# match the whole CCLE expression data with the list containing pathway components
# then add Ensembl IDs as the gene names
for (i in 1:length(gene.list)) {
  ccle.pathways[[i]] <- nor.ccle[nor.ccle$Gene.names %in% gene.list[[i]],]
  row.names(ccle.pathways[[i]]) <- ccle.pathways[[i]][,1]
}

# rename of the dfs in the list with each respective signaling pathway
names(ccle.pathways) <- names(gene.list)

```

Write a function to select cells as the models for pathways. The cells have to express the essential pathway component(s). For example, EGFR will have to express for cell lines used as EGFR signaling model; any of the FGFRs have to express for the FGFR signaling model cells. I initially think that the essentail component(s) have to be highly expressed. However, when I think about it more, I should actually choose the cell lines with a moderate expression. The reason is that I don't want the kinases to drive the signal transduction by auto-phosphorylation. 

```{r cell selecting function}

# I made a table containing the essential genes in each pathway, e.g. EGFR in EGF signaling
essential <- read.delim("signaling_genes/essential_each_pathway.txt", stringsAsFactors = FALSE)

# write a funtion to filter out cells that do not meet a threshold expression of the essential genes
# Will only work on the reactome pathways
# Input argument will be the essential gene data frame
# The expression data (ccle.pathways) is already in the function 
filter.essential.genes <- function(essential.df,        # essential genes df
                                   retain.percentile = NULL    # a length-of-two vector with 
                                                               # the lower and upper expression to be kept
                                                               # NULL will output the expression of the essential genes
                                   ) { 
  pathway <- essential.df["Pathway"]
  essential.gene <- essential.df["Gene"]
  # the expression data is a list of data frame
  # So just extract the pathway data frame that match the pathway name
  filtered.pathway <- ccle.pathways[[pathway]]
  
  # make a new data frame holding the essential gene expression
  essential.gene.expression <- filtered.pathway[grepl(x = filtered.pathway$Gene.names,
                                                      pattern = essential.gene), ]
  
  
  if (length(retain.percentile) == 0) {
    return(essential.gene.expression)
  } else {
    # I think the cells should be expressing the essential genes, but not over-expressing. 
    # Like EGFR will auto-phosphorylate then it will be very hard to turn off the signal.
    # I will test, and remove the cells that are not within the expression range.
  
    # t(apply()) here because i want to fill two columns. 
    # If I don't t(), apply() will fill up percent.5 before percent.6,
    # meaning that percent.5 will have 50 %-tile and 60 %-tile of gene 1 in row 1 and row 2
    # then gene 2 in row 3 and row 4, etc
    essential.gene.expression[, c("low.bound", "hi.bound")] <- t(apply(essential.gene.expression[, 3:1078],
                                                                      1, quantile, probs = retain.percentile))
    # Test expression that are out of range
    test.threshold <- as.data.frame(apply(essential.gene.expression[, 3:1078, drop = FALSE], 2,
                                          function(x) x < essential.gene.expression$low.bound |
                                            x > essential.gene.expression$hi.bound))
  
    # The test was to see what genes are out of the target range,
    # so TRUE will be things that I don't want, i.e. extract cell lines to remove
  
    # The problem is that apply() turn the 1 row data frames into 1 column and n rows df...
    # So I have to make a if... else to test and fix it
    if (ncol(test.threshold) < 2) {
      unwant.cells <- test.threshold[test.threshold[,1] == "TRUE", , drop = FALSE]
      unwant.cells <- row.names(unwant.cells)
    } else {
#      unwant.cells <- names(test.threshold)[apply(test.threshold, 
#                                                  2, function(x) all(x == "TRUE"))]
      unwant.cells <- names(test.threshold)[apply(test.threshold, 
                                                  2, function(x) sum(x == "TRUE")/length(x) >= 0.6)]
    }
  
    # impute the expression data with a very low number for the cells that will be removed 
    filtered.pathway[, unwant.cells] <- 0
  
    return(filtered.pathway)
    }

}

```

I will have to make 2 lists: one contains the selected cells; the other one contains most of the cells. The second list is for mapping where the selected cells sit in the expression spectra. 

```{r selecting cells}

# filtered cells will be for picking the cells to use
filtered.reactomes <- apply(essential, 1, filter.essential.genes, retain.percentile = c(0.4, 0.6))
names(filtered.reactomes) <- sub(pattern = "Reactome.", replacement = "", x = essential$Pathway)

filtered.cells <- filtered.reactomes

filtered.cells <- lapply(filtered.cells, FUN = select, 3:1078)
filtered.cells.sumExp <- lapply(filtered.cells, function(x) data.frame(Sums = colSums(x)))

filtered.cells.sumExp <- Reduce(x = filtered.cells.sumExp, f = function(x,y) cbind(x,y))
names(filtered.cells.sumExp) <- names(filtered.reactomes)

filtered.cells <- filtered.cells.sumExp %>% 
  gather(key = "Pathways", value = "Sum.exp") %>%
  filter(Sum.exp != 0)

reactome.box <- ggplot(filtered.cells) +
  geom_boxplot(mapping = aes(x = Pathways, y = log10(Sum.exp))) +
  theme(axis.text.x = element_text(angle=45),
        axis.title.x = element_blank()) + 
  ggtitle("Sum expression of pathway components")

reactome.box

data.frame(table(filtered.cells$Pathways))


filtered.cells.sumExp$Non0 <- apply(filtered.cells.sumExp, 1, 
                                    function(x) sum(x != 0))

cells.with.six.pathways <- filtered.cells.sumExp %>% 
  mutate(Cells = rownames(filtered.cells.sumExp)) %>%
  filter(Non0 > 5) %>%
  select(-Non0) %>%
  gather(key = "Pathways", value = "Expression", -Cells) %>%
  spread(key = Cells, value = Expression) %>%
  rename(Gene.names = "Pathways") # I need to match the data to the sum data later, by the column names

#write.table(filtered.cells.sumExp, "SumExpressionAllCells.txt", quote = FALSE, append = FALSE, sep = "\t")

picked.cells <- rownames(filtered.cells.sumExp)[filtered.cells.sumExp$Non0 > 5]

picked.cells.expression <- lapply(ccle.pathways[1:11], select, Gene.names, picked.cells)

column.names <- names(cells.with.six.pathways)
for (i in 1:11) {
  picked.cells.expression[[i]][nrow(picked.cells.expression[[i]]) + 1, column.names] <- 
    cells.with.six.pathways[i, ]
}

cleanup <- function(x) {
  x <- data.frame(t(x))
  names(x) <- unname(unlist(x[1, ]))
  x <- x[-1,]
  colnames(x)[ncol(x)] <- "Can.be.used"
  x$Cells <- rownames(x)
  x <- x[, c(ncol(x), ncol(x)-1, 1:(ncol(x)-2))]
  x <- type.convert(x)
  x$Can.be.used <- ifelse(x$Can.be.used == 0, "", "+")
  return(x)
}
picked.cells.expression <- lapply(picked.cells.expression, cleanup)

#write_xlsx(picked.cells.expression, "ModelCells.xlsx")

```

Let's see where are the selected cells sitting in the essential gene expression spectrum. 

```{r see where the cells are at the expression spectrum}

# extract the essential genes from the whole ccle data
pathway.genes.expression.list <- apply(essential, 1, filter.essential.genes)
pathway.names <- sub(pattern = "Reactome.", replacement = "", x = essential$Pathway)
num.of.genes <- sapply(pathway.genes.expression.list, nrow)
pathway.genes.expression <- Reduce(x = pathway.genes.expression.list, f = function(x,y) rbind(x,y))
names(pathway.genes.expression)[1] <- "Pathways"
pathway.genes.expression$Pathways <- rep(pathway.names, times = num.of.genes)

pathway.genes.expression <- pathway.genes.expression %>%
  gather(key = "Cells", value = "Expression", 3:1078)

# tidy up the selected cells for plotting
selected.cells.for.plotting <- lapply(picked.cells.expression, 
                                      function(x) filter(x, Can.be.used == "+") %>% select(1:2))
#selected.cells.for.plotting <- lapply(selected.cells.for.plotting, function(x) names(x)[3] <- "Gene.x")

num.of.cells <- sapply(selected.cells.for.plotting, nrow)
selected.cells.for.plotting <- Reduce(x = selected.cells.for.plotting, f = function(x,y) rbind(x,y))
selected.cells.for.plotting$Pathways <- rep(pathway.names, times = num.of.cells)
selected.cells.for.plotting <- selected.cells.for.plotting %>%
  select(-Can.be.used) %>%
  left_join(., pathway.genes.expression, by = c("Cells", "Pathways"))
  
# plot
p <- ggplot() +
  geom_boxplot(data = pathway.genes.expression, mapping = aes(x = Pathways, y = log10(Expression))) +
  geom_point(data = selected.cells.for.plotting, 
               mapping = aes(x = factor(Pathways), y = log10(Expression),
                             colour = Cells)) +
  xlab("Expression of pathway marker genes") +
  theme(axis.text.x = element_text(angle=45),
        panel.background = element_rect(colour = "black", fill = "white"))

p

```

Exported the above results. But it will probably be good to know the actual marker gene expression. So lets add it.

```{r get the sum of marker genes expression}

pathway.genes.expression.list <- pathway.genes.expression.list # this is from above
pathway.genes.sum <- lapply(pathway.genes.expression.list, 
                                       function(x) data.frame(apply(x[-c(1,2)], 2, sum)))
pathway.genes.sum <- Reduce(x = pathway.genes.sum, 
                                       f = function(x,y) cbind(x,y))
names(pathway.genes.sum) <- pathway.names
pathway.genes.sum$Cells <- rownames(pathway.genes.sum)
pathway.genes.sum <- select(pathway.genes.sum, Cells, 1:11)

# get the percentile of sum expression, then group them into different classes
get.percentile.group <- function(x) {
  break.points <- quantile(x, probs = c(0, .05, .25, .4, .6, .75, .95, 1))
  cut(x, 
      breaks = break.points, 
      labels = c(-3, -2, -1, 0, 1, 2, 3),
      include.lowest = TRUE)            # in help, the (a,b] notation means that a is not included, 
                                        # so for 0 - 5 % (0,0.05], lowest number is excluded, include.lowest = TRUE change that
}

# make a new df to hold the groups 
pathway.genes.group <- pathway.genes.sum
pathway.genes.group[, 2:12] <- apply(pathway.genes.sum[, 2:12], 2, get.percentile.group )
pathway.genes.group$Num.of.medianExp <- apply(pathway.genes.group[,2:12], 1, 
                                              function(x) sum(x == 0))

# prepare and make the boxplot
sum.for.plotting <- gather(pathway.genes.sum, key = "Pathways", value = "SumExp", 2:12)
picked.cells.by.group <- pathway.genes.group$Cells[pathway.genes.group$Num.of.medianExp > 5]

g <- ggplot() +
  geom_boxplot(sum.for.plotting, mapping = aes(x = Pathways, y = log10(SumExp))) +
  geom_point(sum.for.plotting[sum.for.plotting$Cells %in% picked.cells.by.group,],
             mapping = aes(x = Pathways, y = log10(SumExp), colour = Cells)) +
  theme(axis.text.x = element_text(angle = 30),
        panel.background = element_rect(colour = "black", fill = "white"))

# I am wondering if there is any correlation between pathways, but no
pathway.genes.sum.log <- apply(pathway.genes.sum[,2:12], 2, function(x) log10(x))
psych::pairs.panels(pathway.genes.sum.log)

# export
#percentile.grouping <- list(pathway.genes.sum, pathway.genes.group)
#names(percentile.grouping) <- c("Sum.marker.genes.expression", "Percentile.group")
#write_xlsx(percentile.grouping, "ModelCells_percentileGroups.xlsx")

```

