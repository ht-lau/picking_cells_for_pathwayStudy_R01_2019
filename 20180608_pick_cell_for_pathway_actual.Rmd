---
title: "Selection of CCLE based on the sum expression of signaling components"
output:
  html_document:
    df_print: paged
---

In the previous script, I determined that the sums normalized expression gene expression from each signaling pathway is probably the easiest way to choose what cell lines to use. The outliner cell lines can be identified using the box plot. Basically, the cell lines with a sum expression value higher than 75% quantile + 1.5 * IQR. 

Followings are the signaling pathways chosen. Any pathways labeled as NA is not found in Reactome, but is in the original R01 proposal. These pathways are labeled as "Reactome".

EGF: Signal Transduction, Signaling by RTKs, Signaling by EGFR
FGF: Signal Transduction, Signaling by RTKs, Signaling by FGFR
HGF: Signal Transduction, Signaling by RTKs, Signaling by MET
TGFb: Signal Transduction, Signaling by TGF-beta, Signaling by TGF-beta receptor
IL6: Immune Sys, Cytokine Signaling, Signaling by IL, IL-6
WNTs: Signal Transduction, Signaling by WNT, TCF dependent signaling in response to WNT
SHH: Signal Transduction, Signaling by Hedgehog
Estrogen: Signal Transduction, Signaling by NR, ESR-mediated signaling
Glucose: Signal Transduction, Signaling by RTK, Signaling by Insulin receptor
Oxygen: Cell. responses to ext. stimuli, Cell. response to stress, hypoxia
PPMs/ECM: Extracellular matrix organization, Integrin cell surface interactions

The oncogenic pathways from Sanchez-Vega et. al. (2018) (PMID: 29625050) were also included in this version of the report. These are labeled as "TCGA"


Note 03/04/2019: we got the R01, the money is smaller than we asked for because of a budget cut (?). At least the lab can survive... Anyways, in the original version of this script, I did not check whether the receptors/essential components are expressed. I do actually know that some cells with high pathway expression level do not have the, say, EGFR expressed. So this version will fix this problem.

```{r packages, message=FALSE, echo=FALSE}
library(tidyverse)
library(ggthemes)
library(ggpubr)
library(readxl)
library(qdapTools)  # required to turn the gene.list into df, list2df()
library(VennDiagram)
library(colorRamps)
library(RColorBrewer)
```

```{r reactome gene list + TCGA oncogenes, echo=FALSE}
########
# can skip, if I am doing the same thing, there is a break point at 
# {r match the signaling component and calculate the sum of expressions}
########


# this part deal with the data I downloaded from the Reactome.
# Mainly, I want to extract the genes involved in each pathway.
# This will produce a list that I can use to match with the CCLE expression data

# There is also a paper published from TCGA looking at the 


# read the files containing the signaling components into a list
signaling.files <- list.files(path = "signaling_genes", pattern = "by_",
                              full.names = TRUE)            # full name extract the path

# use the file list created above to read the files into a list of df
# this dfs contain the data from reactome, which have to clean up further to extract the genes
gene.list <- lapply(signaling.files, read.delim, header = TRUE, stringsAsFactors = FALSE)

# extract the pathway names from the file list
pathway.names <- lapply(signaling.files, str_sub, 20, -5)

# add pathway names back to the file list
names(gene.list) <- pathway.names


############################################################
# The gene.list contains a lot of information that I don't need from the Reactome.
# So write a function to clean it up.
############################################################

extract.genes <- function(x, MoleculeType, MoleculeName) {
  x <- x %>% 
    filter(MoleculeType == "Proteins") %>% 
    separate(MoleculeName, into = c("Uniprot", "Gene.names"), sep = " ")
  x <- x[!duplicated(x$Gene.names), ]
  x <- x$Gene.names
}

# clean up the gene list with the new function
gene.list <- lapply(gene.list, FUN = extract.genes)
names(gene.list) <- str_c("Reactome.", names(gene.list))


# check the common set between RTKs
RTK <- gene.list[c("Reactome.EGFR", "Reactome.FGFR", "Reactome.Insulin_receptor")]

EGFR.WNT <- gene.list[c("Reactome.EGFR", "Reactome.TCF_Wnt")]

x <- gene.list$Reactome.TCF_Wnt[gene.list$Reactome.TCF_Wnt %in% gene.list$Reactome.EGFR]
y <- gene.list$Reactome.EGFR[gene.list$Reactome.EGFR %in% gene.list$Reactome.TCF_Wnt]
z <- gene.list$Reactome.EGFR[gene.list$Reactome.EGFR %in% gene.list$Reactome.FGFR]
```


```{r this is the TCGA list, echo=FALSE}

################################################################
# import of the TCGA data
################################################################

# an excel sheet, I only need the column 1 and 2, which are the pathways and genes, respectively 
SanchezVega <- read_excel("FigS3_SanchezVega_Cell.xlsx", sheet = "Pathways") %>%
  select(1:2)

# make a vectors containing the name of the pathways
SanchezVega.pathways <- SanchezVega$Pathway[!duplicated(SanchezVega$Pathway)]

# i want to create a list of vector containing the pathway components
tcga.gene.list <- list() # make an empty list 1st
for (n in 1:length(SanchezVega.pathways)) {
  tcga.gene.list[[n]] <- SanchezVega$Gene[SanchezVega$Pathway == SanchezVega.pathways[n]]
}
names(tcga.gene.list) <- str_c("TCGA.", SanchezVega.pathways)

##########################
# combine the TCGA and Reactome list
##########################

gene.list <- c(gene.list, tcga.gene.list)
```

There are 1326 genes in total (with duplcations) or 940 (without duplication). Among these, the TCGA data contains 310 (309) genes and Reactome contains 1016 (736 unique) genes. With 105 common genes.
```{r plotting the pathways, echo=FALSE}

gene.list.long <- list2df(gene.list)
names(gene.list.long)[1:2] <- c("Gene.names", "Pathways")
gene.list.long <- gene.list.long %>% separate(Pathways, into = c("Sources", "Pathways"), sep = "\\.")

ggplot(gene.list.long) +
  geom_bar(mapping = aes(x = Pathways)) +
  facet_wrap(~ Sources) +
  theme(axis.text.x = element_text(angle = 60, hjust = 1),
        panel.background = element_rect(fill = "white", colour = "grey50"))

Reactome.vs.TCGA <- ggplot(gene.list.long) +
  geom_bar(mapping = aes(x = Pathways)) +
  facet_wrap(~ Sources) +
  theme(axis.text.x = element_text(angle = 60, hjust = 1),
        panel.background = element_rect(fill = "white", colour = "grey50"))

# see how many of the TCGA genes are actually covered in the Reactome

tcga.genes <- gene.list.long$Gene.names[gene.list.long$Sources == "TCGA"]
sum(!duplicated(tcga.genes))

reactome.genes <- gene.list.long$Gene.names[gene.list.long$Sources == "Reactome"]
sum(!duplicated(reactome.genes))

x <- calculate.overlap(list(tcga.genes, reactome.genes))

sum(reactome.genes %in% tcga.genes)
sum(tcga.genes %in% reactome.genes)
```


```{r match the signaling component and calculate the sum of expressions, echo=FALSE}
########
# this part save the output, so I don't have to re-load the big data frame again
########

# import the previously produced normalized CCLE expression data
nor.ccle <- read.delim("Normalized_CCLE_RNAseq.txt", header = TRUE, stringsAsFactors = FALSE)


# create a new list to whole the list of df with pathway component expression values
ccle.pathways <- list()

# match the whole CCLE expression data with the list containing pathway components
# then add Ensembl IDs as the gene names
for (i in 1:length(gene.list)) {
  ccle.pathways[[i]] <- nor.ccle[nor.ccle$Gene.names %in% gene.list[[i]],]
  row.names(ccle.pathways[[i]]) <- ccle.pathways[[i]][,1]
}

# rename of the dfs in the list with each respective signaling pathway
names(ccle.pathways) <- names(gene.list)

# filter cells with low expression of the essential component
essential <- read.delim("signaling_genes/essential_each_pathway.txt", stringsAsFactors = FALSE)

filter.essential.genes <- function(essential.df) {
  pathway <- essential.df["Pathway"]
  essential.gene <- essential.df["Gene"]
  filtered.pathway <- ccle.pathways[[pathway]]
  
  essential.gene.expression <- filtered.pathway[grepl(x = filtered.pathway$Gene.names,
                                                      pattern = essential.gene), ]
  
  essential.gene.expression$Median <- apply(essential.gene.expression[, 3:1078], 
                                            1, median)
  test.median <- as.data.frame(apply(essential.gene.expression[, 3:1078, drop = FALSE],
                                     2, function(x) x > essential.gene.expression$Median))
  
  if (ncol(test.median) < 2) {
    retaining.cells <- test.median[test.median[,1] == "TRUE", , drop = FALSE]
    retaining.cells <- row.names(retaining.cells)
  } else {
    retaining.cells <- names(test.median)[apply(test.median, 
                                                2, function(x) any(x == "TRUE"))]
  }

  return(retaining.cells)
}
  
test <- apply(essential, 1, filter.essential.genes)

test.code <- lapply(test, ncol)
test.code <- test[[3]]
test.code <- test.code[, c(3:5, 1079)]
test.code <- as.data.frame(apply(test.code[,1:3], 2, function(x) x > test.code$Median))
test.code$Sim <- rep(FALSE, 5)
test.code <- names(test.code)[apply(test.code, 2, function(x) any(x == "TRUE"))]

test.code <- test[[1]]
test.code <- test.code[test.code[,1] == "TRUE",, drop = FALSE]
test.code <- row.names(test.code)

# remove the columns containing Ensembl IDs and gene names, so that I can do calculations
ccle.pathways <- lapply(ccle.pathways, FUN = select, 3:1078)

# calculate the sums of expression of pathway component in each cell lines
sum.gene.expression <- lapply(ccle.pathways, function(x) data.frame(Sums = colSums(x)))


# this pretty much done with the dataframe, so I can move on to selecting the cell lines
# as well as data visualization

# this is new to me! So I can save the list, and have a break point to clean up the rams!
save(sum.gene.expression, file = "sum_of_expression.RData")
```

```{r loading saved R data, echo=FALSE}
load("sum_of_expression.RData")
```

```{r calculate the quantile of each cell line with the pathway}

# I originally gave Shao-En a table containing a "+" for cell lines that have a high enough 
# expression of the pathway components. However, there is no information about the other
# pathways. To solve this, I want to produce another table containing the quantile to show
# where the particular cell line is sit in.

# the following function basically produced a list containing the quantiles of each pathway
# Then I just put the quantile in using if ... else statments. 
# This is not beautiful and very stupid!!!
add.quantile <- function(test) {
  quantile.in.pathway <- quantile(test[,1])
  test[,2] <- NA
  for (i in 1:nrow(test)) {
    if (test[i, 1] < quantile.in.pathway[[2]]) {
      test[i, 2] <- "< 25"
    } else if (test[i, 1] < quantile.in.pathway[[3]]) {
      test[i, 2] <- "< 50"
    } else if (test[i, 1] < quantile.in.pathway[[4]]) {
      test[i, 2] <- "< 75"
    } else {
      test[i, 2] <- "> 75"
    }
    colnames(test)[2] <- "Quantile"
  }
  return(test)
}

sum.gene.expression <- lapply(sum.gene.expression, add.quantile)

# change the name of the quantile columns
for (i in 1:21) {
  colnames(sum.gene.expression[[i]])[2] <- str_c("Quantile_", names(sum.gene.expression[i]))
  colnames(sum.gene.expression[[i]])[1] <- str_c("Sum_", names(sum.gene.expression[i]))
  # extract the cell names from row.names
  sum.gene.expression[[i]]$Cells <- row.names(sum.gene.expression[[i]])
}

# combine all of the dfs into 1 using reduce()
cell.pathway.sum.quantile <- reduce(sum.gene.expression, 
                                function(df1, df2) left_join(df1, df2, by = "Cells"))
# move the cell names to the 1st column and remove the columns containing the sum of expression
cell.pathway.quantile <- select(cell.pathway.sum.quantile, 3, contains("Quantile"))

# change to long form to help matching to the selected cell lines later
# also correct the pathway names in the pathway column, all of them contain "Quantile_" now. 
cell.pathway.quantile <- cell.pathway.quantile %>%
  gather(key = "Pathways", value = "Quantiles", -Cells) %>%
  separate(col = Pathways, into = c("crap", "Pathways"), sep = "e_") %>%
  select(-crap)

# also make another df containing the sum of component expression instead of just the quantile
cell.pathway.sum <- select(cell.pathway.sum.quantile, 3, contains("Sum")) %>%
  gather(key = "Pathways", value = "Sum.of.expression", -Cells) %>%
  separate(col = Pathways, into = c("crap", "Pathways"), sep = "m_") %>%
  select(-crap)

```

```{r calculate cut off and pick cell lines, echo=FALSE}
# I want to pick the cut off base on the boxplot, 
# the whisker of the boxplot is 75 % quantile + 1.5 * IQR

# write a function to calculate the cut off for each pathway for picking the cells
cal.cut.off <- function(x) {
  cut.off <- quantile(x[1][,1], 0.75) + 1.5 * IQR(x[1][,1])
}

# make the list containing the cut off values 
cut.off.list <- lapply(sum.gene.expression, FUN = cal.cut.off)
# turn the list into a df
cut.off.list <- data.frame(Cut.off = unlist(cut.off.list))

########
# picking the cells here
########

# at this point, the dfs contain 2 columns, 
# the sum of component expression and the quantile that the cell lines are sitting in each pathway

# make a list of df to hold the cells
cells.list <- list()

# the for loop to get the cells. Have to use two lists for this
# 1. the list containing the sum of gene expressions
# 2. the list containing the cut off 
for (i in 1:21) {
  cells.list[[i]] <- sum.gene.expression[[i]][sum.gene.expression[[i]][,1] >= 
                                                cut.off.list[i, 1], ,
                                              drop = FALSE]
  # add a column containing the pathway names, just to preserve it for later
  cells.list[[i]][1:nrow(cells.list[[i]]), 3] <- "+"
  colnames(cells.list[[i]])[3] <- names(sum.gene.expression[i])
  
  # the cell line names are the row names now, I want to convert it into a column
  cells.list[[i]][1:nrow(cells.list[[i]]), 4] <- row.names(cells.list[[i]])
  cells.list[[i]] <- select(cells.list[[i]], Cells = 4, 3)
}

# reduce repeat the function in a sequential manner, until it finished the list, I think
# the input is a list, then I added the function with 2 inputs and run full_join()
cells.list <- reduce(cells.list, function(df1, df2) full_join(df1, df2, by = "Cells"))

# convert to long form to match with quantile data
cells.list <- cells.list %>%
  gather(key = "Pathways", value = "Picked", -Cells)

# match the picked cell with the quantile information, added a column
cells.list.quantile <- left_join(cells.list, cell.pathway.quantile, by = c("Cells", "Pathways"))

# fill the NAs in the picked cells column with the quantile number, then remove the information, turn back to wide format
cells.list.quantile <- cells.list.quantile %>%
  mutate(Picked = ifelse(is.na(cells.list.quantile$Picked), 
                         cells.list.quantile$Quantiles, 
                         cells.list.quantile$Picked)) %>%
  select(-Quantiles) %>%
  spread(key = Pathways, value = Picked)

# use str_split, because I can choose how many items the original string will be splitting into
temp <- str_split(string = cells.list.quantile$Cells, pattern = "_", n = 2)
temp <- data.frame(matrix(unlist(temp), ncol = 2, byrow = TRUE))
colnames(temp)[1:2] <- c("Cell.lines", "Tissues")
cells.list.quantile <- cbind(temp, cells.list.quantile[, 2:22])

#write.table(cells.list, "Picked_cells.txt", sep = "\t",
#            row.names = FALSE, quote = FALSE, append = FALSE)

##############################
# match picked cells with sum of expression data. SE wants to try clustering
##############################

# match the picked cell with the quantile information, added a column
cells.list.sum <- left_join(cells.list, cell.pathway.sum, by = c("Cells", "Pathways"))

# fill the NAs in the picked cells column with the quantile number, then remove the information, turn back to wide format
cells.list.sum <- cells.list.sum %>%
  select(-Picked) %>%
  spread(key = Pathways, value = Sum.of.expression)

# use str_split, because I can choose how many items the original string will be splitting into
temp <- str_split(string = cells.list.sum$Cells, pattern = "_", n = 2)
temp <- data.frame(matrix(unlist(temp), ncol = 2, byrow = TRUE))
colnames(temp)[1:2] <- c("Cell.lines", "Tissues")
cells.list.sum <- cbind(temp, cells.list.sum[, 2:22])

write.table(cells.list.sum, "Picked_cells_sum_expression.txt", sep = "\t",
            row.names = FALSE, quote = FALSE, append = FALSE)

```

And there are 500 cell lines from 23 tissue types
```{r plotting cells data, echo=FALSE}

ggplot(cells.list) +
  geom_bar(mapping = aes(x = Tissues)) +
  theme(axis.text.x = element_text(angle = 60, hjust = 1),
        panel.background = element_rect(fill = "white", colour = "grey50")) +
  guides(fill=FALSE)

tissue.types <- ggplot(cells.list) +
  geom_bar(mapping = aes(x = Tissues)) +
  theme(axis.text.x = element_text(angle = 60, hjust = 1),
        panel.background = element_rect(fill = "white", colour = "grey50")) +
  guides(fill=FALSE)
```

```{r %pathway in each tissue type, echo=FALSE}

# I want to see which the percentage of each pathway in each tissue type

# change the list into a long form
cells.list.long <- cells.list %>%
  gather(key = "Pathways", value = "meh", 3:23) %>%
  filter(!is.na(meh))

# then get a count table for the cell lines, basically how many cell line is in each pathway in each tissue type
x <- data.frame(table(cells.list.long[, 2:3]))

# then group the data by tissue type and calculate the percentage of pathway
y <- group_by(x, Tissues) %>% mutate(Percent = Freq/sum(Freq) * 100)

# Clean up the table
z <- y %>% mutate(Percent = ifelse(Percent == 0, NA, Percent)) %>%
  select(-Freq) %>%
  spread(key = Pathways, value = Percent) 

# plot it out
ggplot(y) +
  geom_bar(mapping = aes(x = Tissues, y = Percent, fill = Pathways), stat = "identity") +
  theme(axis.text.x = element_text(angle = 60, hjust = 1),
        panel.background = element_rect(fill = "white")) +
  scale_fill_manual(values = colorRampPalette(brewer.pal(9, "Set1"))(23))

percent_of_pathway <- ggplot(y) +
  geom_bar(mapping = aes(x = Tissues, y = Percent, fill = Pathways), stat = "identity") +
  theme(axis.text.x = element_text(angle = 60, hjust = 1),
        panel.background = element_rect(fill = "white")) +
  scale_fill_manual(values = colorRampPalette(brewer.pal(9, "Set1"))(23)) 
```


Following is the example for how cell lines are picked based on their expression level of the pathway components.
```{r select cells and data visualisation, echo=FALSE}

# take EGF signaling out, I want to use it as an example to show the way we select cells
egf <- sum.gene.expression$Reactome.EGFR

# add a column just for the plotting
egf$xaxis <- 1:nrow(egf) 
egf$box.axis <- "EGF"

# calculate the cut off, which should be 75 % quantile + 1.5 x IQR
cut.off <- quantile(egf$Sums, 0.75) + 1.5 * IQR(egf$Sums)
# then separate the data to 2 groups based on the cut off
egf$Picked <- egf$Sums >= cut.off

# I want to see if I can do a scatter plot with boxplot next to it, which require the ggpubr
scatter.plot <- ggscatter(egf, 
                          x = "xaxis", y = "Sums", 
                          color = "Picked", palette = c("Grey", "Red"))

# the boxplot 
box <- ggboxplot(egf, x = "box.axis", y = "Sums", 
                 alpha = 0.5, 
                 fill = "grey") + clean_theme()

combine.plot <- ggarrange(scatter.plot, box,
          ncol = 2, align = "h",
          widths = c(9, 1), heights = c(1,1),
          common.legend = TRUE)

```


