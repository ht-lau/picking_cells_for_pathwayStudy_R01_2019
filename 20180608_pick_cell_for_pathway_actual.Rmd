---
title: "Selection of CCLE based on the sum expression of signaling components"
output:
  html_document:
    df_print: paged
---

In the previous script, I determined that the sums normalized expression gene expression from each signaling pathway is probably the easiest way to choose what cell lines to use. The outliner cell lines can be identified using the box plot. Basically, the cell lines with a sum expression value higher than 75% quantile + 1.5 * IQR. 

Followings are the signaling pathways chosen. Any pathways labeled as NA is not found in Reactome, but is in the original R01 proposal. These pathways are labeled as "Reactome".

EGF: Signal Transduction, Signaling by RTKs, Signaling by EGFR
FGF: Signal Transduction, Signaling by RTKs, Signaling by FGFR
HGF: Signal Transduction, Signaling by RTKs, Signaling by MET
TGFb: Signal Transduction, Signaling by TGF-beta, Signaling by TGF-beta receptor
IL6: Immune Sys, Cytokine Signaling, Signaling by IL, IL-6
WNTs: Signal Transduction, Signaling by WNT, TCF dependent signaling in response to WNT
SHH: Signal Transduction, Signaling by Hedgehog
Estrogen: Signal Transduction, Signaling by NR, ESR-mediated signaling
Glucose: Signal Transduction, Signaling by RTK, Signaling by Insulin receptor
Oxygen: Cell. responses to ext. stimuli, Cell. response to stress, hypoxia
PPMs/ECM: Extracellular matrix organization, Integrin cell surface interactions

The oncogenic pathways from Sanchez-Vega et. al. (2018) (PMID: 29625050) were also included in this version of the report. These are labeled as "TCGA"


Note 03/04/2019: we got the R01, the money is smaller than we asked for because of a budget cut (?). At least the lab can survive... Anyways, in the original version of this script, I did not check whether the receptors/essential components are expressed. I do actually know that some cells with high pathway expression level do not have the, say, EGFR expressed. So this version will fix this problem.

```{r packages, message=FALSE, echo=FALSE}
library(tidyverse)
library(ggthemes)
library(ggpubr)
library(readxl)
library(writexl)
library(qdapTools)  # required to turn the gene.list into df, list2df()
library(VennDiagram)
library(colorRamps)
library(RColorBrewer)
library(gplots)
```

```{r reactome gene list + TCGA oncogenes, echo=FALSE}
########
# can skip, if I am doing the same thing, there is a break point at 
# {r match the signaling component and calculate the sum of expressions}
########


# this part deal with the data I downloaded from the Reactome.
# Mainly, I want to extract the genes involved in each pathway.
# This will produce a list that I can use to match with the CCLE expression data

# There is also a paper published from TCGA looking at the 


# read the files containing the signaling components into a list
signaling.files <- list.files(path = "signaling_genes", pattern = "by_",
                              full.names = TRUE)            # full name extract the path

# use the file list created above to read the files into a list of df
# this dfs contain the data from reactome, which have to clean up further to extract the genes
gene.list <- lapply(signaling.files, read.delim, header = TRUE, stringsAsFactors = FALSE)

# extract the pathway names from the file list
pathway.names <- lapply(signaling.files, str_sub, 20, -5)

# add pathway names back to the file list
names(gene.list) <- pathway.names


############################################################
# The gene.list contains a lot of information that I don't need from the Reactome.
# So write a function to clean it up.
############################################################

extract.genes <- function(x, MoleculeType, MoleculeName) {
  x <- x %>% 
    filter(MoleculeType == "Proteins") %>% 
    separate(MoleculeName, into = c("Uniprot", "Gene.names"), sep = " ")
  x <- x[!duplicated(x$Gene.names), ]
  x <- x$Gene.names
}

# clean up the gene list with the new function
gene.list <- lapply(gene.list, FUN = extract.genes)
names(gene.list) <- str_c("Reactome.", names(gene.list))


# check the common set between RTKs
RTK <- gene.list[c("Reactome.EGFR", "Reactome.FGFR", "Reactome.Insulin_receptor")]

EGFR.WNT <- gene.list[c("Reactome.EGFR", "Reactome.TCF_Wnt")]

x <- gene.list$Reactome.TCF_Wnt[gene.list$Reactome.TCF_Wnt %in% gene.list$Reactome.EGFR]
y <- gene.list$Reactome.EGFR[gene.list$Reactome.EGFR %in% gene.list$Reactome.TCF_Wnt]
z <- gene.list$Reactome.EGFR[gene.list$Reactome.EGFR %in% gene.list$Reactome.FGFR]
```


```{r this is the TCGA list, echo=FALSE}

################################################################
# import of the TCGA data
################################################################

# an excel sheet, I only need the column 1 and 2, which are the pathways and genes, respectively 
SanchezVega <- read_excel("FigS3_SanchezVega_Cell.xlsx", sheet = "Pathways") %>%
  select(1:2)

# make a vectors containing the name of the pathways
SanchezVega.pathways <- SanchezVega$Pathway[!duplicated(SanchezVega$Pathway)]

# i want to create a list of vector containing the pathway components
tcga.gene.list <- list() # make an empty list 1st
for (n in 1:length(SanchezVega.pathways)) {
  tcga.gene.list[[n]] <- SanchezVega$Gene[SanchezVega$Pathway == SanchezVega.pathways[n]]
}
names(tcga.gene.list) <- str_c("TCGA.", SanchezVega.pathways)

##########################
# combine the TCGA and Reactome list
##########################

gene.list <- c(gene.list, tcga.gene.list)
```

There are 1326 genes in total (with duplcations) or 940 (without duplication). Among these, the TCGA data contains 310 (309) genes and Reactome contains 1016 (736 unique) genes. With 105 common genes.
```{r plotting the pathways, echo=FALSE}

gene.list.long <- list2df(gene.list)
names(gene.list.long)[1:2] <- c("Gene.names", "Pathways")
gene.list.long <- gene.list.long %>% separate(Pathways, into = c("Sources", "Pathways"), sep = "\\.")

ggplot(gene.list.long) +
  geom_bar(mapping = aes(x = Pathways)) +
  facet_wrap(~ Sources) +
  theme(axis.text.x = element_text(angle = 60, hjust = 1),
        panel.background = element_rect(fill = "white", colour = "grey50"))

Reactome.vs.TCGA <- ggplot(gene.list.long) +
  geom_bar(mapping = aes(x = Pathways)) +
  facet_wrap(~ Sources) +
  theme(axis.text.x = element_text(angle = 60, hjust = 1),
        panel.background = element_rect(fill = "white", colour = "grey50"))

# see how many of the TCGA genes are actually covered in the Reactome

tcga.genes <- gene.list.long$Gene.names[gene.list.long$Sources == "TCGA"]
sum(!duplicated(tcga.genes))

reactome.genes <- gene.list.long$Gene.names[gene.list.long$Sources == "Reactome"]
sum(!duplicated(reactome.genes))

x <- calculate.overlap(list(tcga.genes, reactome.genes))

sum(reactome.genes %in% tcga.genes)
sum(tcga.genes %in% reactome.genes)
```

```{r match the signaling component and calculate the sum of expressions, echo=FALSE}
########
# this part save the output, so I don't have to re-load the big data frame again
########

# import the previously produced normalized CCLE expression data
nor.ccle <- read.delim("Normalized_CCLE_RNAseq.txt", header = TRUE, stringsAsFactors = FALSE)


# create a new list to whole the list of df with pathway component expression values
ccle.pathways <- list()

# match the whole CCLE expression data with the list containing pathway components
# then add Ensembl IDs as the gene names
for (i in 1:length(gene.list)) {
  ccle.pathways[[i]] <- nor.ccle[nor.ccle$Gene.names %in% gene.list[[i]],]
  row.names(ccle.pathways[[i]]) <- ccle.pathways[[i]][,1]
}

# rename of the dfs in the list with each respective signaling pathway
names(ccle.pathways) <- names(gene.list)

```

Write a function to select cells as the models for pathways. The cells have to express the essential pathway component(s). For example, EGFR will have to express for cell lines used as EGFR signaling model; any of the FGFRs have to express for the FGFR signaling model cells. I initially think that the essentail component(s) have to be highly expressed. However, when I think about it more, I should actually choose the cell lines with a moderate expression. The reason is that I don't want the kinases to drive the signal transduction by auto-phosphorylation. 

```{r cell selecting function}

# I made a table containing the essential genes in each pathway, e.g. EGFR in EGF signaling
essential <- read.delim("signaling_genes/essential_each_pathway.txt", stringsAsFactors = FALSE)

# write a funtion to filter out cells that do not meet a threshold expression of the essential genes
# Will only work on the reactome pathways
# Input argument will be the essential gene data frame
# The expression data (ccle.pathways) is already in the function 
filter.essential.genes <- function(essential.df,        # essential genes df
                                   retain.percentile = NULL    # a length-of-two vector with 
                                                               # the lower and upper expression to be kept
                                                               # NULL will output the expression of the essential genes
                                   ) { 
  pathway <- essential.df["Pathway"]
  essential.gene <- essential.df["Gene"]
  # the expression data is a list of data frame
  # So just extract the pathway data frame that match the pathway name
  filtered.pathway <- ccle.pathways[[pathway]]
  
  # make a new data frame holding the essential gene expression
  essential.gene.expression <- filtered.pathway[grepl(x = filtered.pathway$Gene.names,
                                                      pattern = essential.gene), ]
  
  
  if (length(retain.percentile) == 0) {
    return(essential.gene.expression)
  } else {
    # I think the cells should be expressing the essential genes, but not over-expressing. 
    # Like EGFR will auto-phosphorylate then it will be very hard to turn off the signal.
    # I will test, and remove the cells that are not within the expression range.
  
    # t(apply()) here because i want to fill two columns. 
    # If I don't t(), apply() will fill up percent.5 before percent.6,
    # meaning that percent.5 will have 50 %-tile and 60 %-tile of gene 1 in row 1 and row 2
    # then gene 2 in row 3 and row 4, etc
    essential.gene.expression[, c("low.bound", "hi.bound")] <- t(apply(essential.gene.expression[, 3:1078],
                                                                      1, quantile, probs = retain.percentile))
    # Test expression that are out of range
    test.threshold <- as.data.frame(apply(essential.gene.expression[, 3:1078, drop = FALSE], 2,
                                          function(x) x < essential.gene.expression$low.bound |
                                            x > essential.gene.expression$hi.bound))
  
    # The test was to see what genes are out of the target range,
    # so TRUE will be things that I don't want, i.e. extract cell lines to remove
  
    # The problem is that apply() turn the 1 row data frames into 1 column and n rows df...
    # So I have to make a if... else to test and fix it
    if (ncol(test.threshold) < 2) {
      unwant.cells <- test.threshold[test.threshold[,1] == "TRUE", , drop = FALSE]
      unwant.cells <- row.names(unwant.cells)
    } else {
#      unwant.cells <- names(test.threshold)[apply(test.threshold, 
#                                                  2, function(x) all(x == "TRUE"))]
      unwant.cells <- names(test.threshold)[apply(test.threshold, 
                                                  2, function(x) sum(x == "TRUE")/length(x) >= 0.6)]
    }
  
    # impute the expression data with a very low number for the cells that will be removed 
    filtered.pathway[, unwant.cells] <- 0
  
    return(filtered.pathway)
    }

}

```

I will have to make 2 lists: one contains the selected cells; the other one contains most of the cells. The second list is for mapping where the selected cells sit in the expression spectra. 

```{r selecting cells}

# filtered cells will be for picking the cells to use
filtered.reactomes <- apply(essential, 1, filter.essential.genes, retain.percentile = c(0.4, 0.6))
names(filtered.reactomes) <- sub(pattern = "Reactome.", replacement = "", x = essential$Pathway)

filtered.cells <- filtered.reactomes

filtered.cells <- lapply(filtered.cells, FUN = select, 3:1078)
filtered.cells.sumExp <- lapply(filtered.cells, function(x) data.frame(Sums = colSums(x)))

filtered.cells.sumExp <- Reduce(x = filtered.cells.sumExp, f = function(x,y) cbind(x,y))
names(filtered.cells.sumExp) <- names(filtered.reactomes)

filtered.cells <- filtered.cells.sumExp %>% 
  gather(key = "Pathways", value = "Sum.exp") %>%
  filter(Sum.exp != 0)

reactome.box <- ggplot(filtered.cells) +
  geom_boxplot(mapping = aes(x = Pathways, y = log10(Sum.exp))) +
  theme(axis.text.x = element_text(angle=45),
        axis.title.x = element_blank()) + 
  ggtitle("Sum expression of pathway components")

reactome.box

data.frame(table(filtered.cells$Pathways))


filtered.cells.sumExp$Non0 <- apply(filtered.cells.sumExp, 1, 
                                    function(x) sum(x != 0))

cells.with.six.pathways <- filtered.cells.sumExp %>% 
  mutate(Cells = rownames(filtered.cells.sumExp)) %>%
  filter(Non0 > 5) %>%
  select(-Non0) %>%
  gather(key = "Pathways", value = "Expression", -Cells) %>%
  spread(key = Cells, value = Expression) %>%
  rename(Gene.names = "Pathways") # I need to match the data to the sum data later, by the column names

#write.table(filtered.cells.sumExp, "SumExpressionAllCells.txt", quote = FALSE, append = FALSE, sep = "\t")

picked.cells <- rownames(filtered.cells.sumExp)[filtered.cells.sumExp$Non0 > 5]

picked.cells.expression <- lapply(ccle.pathways[1:11], select, Gene.names, picked.cells)

column.names <- names(cells.with.six.pathways)
for (i in 1:11) {
  picked.cells.expression[[i]][nrow(picked.cells.expression[[i]]) + 1, column.names] <- 
    cells.with.six.pathways[i, ]
}

cleanup <- function(x) {
  x <- data.frame(t(x))
  names(x) <- unname(unlist(x[1, ]))
  x <- x[-1,]
  colnames(x)[ncol(x)] <- "Can.be.used"
  x$Cells <- rownames(x)
  x <- x[, c(ncol(x), ncol(x)-1, 1:(ncol(x)-2))]
  x <- type.convert(x)
  x$Can.be.used <- ifelse(x$Can.be.used == 0, "", "+")
  return(x)
}
picked.cells.expression <- lapply(picked.cells.expression, cleanup)

#write_xlsx(picked.cells.expression, "ModelCells.xlsx")

```

Let's see where are the selected cells sitting in the essential gene expression spectrum. 

```{r see where the cells are at the expression spectrum}

# extract the essential genes from the whole ccle data
pathway.genes.expression.list <- apply(essential, 1, filter.essential.genes)
pathway.names <- sub(pattern = "Reactome.", replacement = "", x = essential$Pathway)
num.of.genes <- sapply(pathway.genes.expression.list, nrow)
pathway.genes.expression <- Reduce(x = pathway.genes.expression.list, f = function(x,y) rbind(x,y))
names(pathway.genes.expression)[1] <- "Pathways"
pathway.genes.expression$Pathways <- rep(pathway.names, times = num.of.genes)

pathway.genes.expression <- pathway.genes.expression %>%
  gather(key = "Cells", value = "Expression", 3:1078)

# tidy up the selected cells for plotting
selected.cells.for.plotting <- lapply(picked.cells.expression, 
                                      function(x) filter(x, Can.be.used == "+") %>% select(1:2))
#selected.cells.for.plotting <- lapply(selected.cells.for.plotting, function(x) names(x)[3] <- "Gene.x")

num.of.cells <- sapply(selected.cells.for.plotting, nrow)
selected.cells.for.plotting <- Reduce(x = selected.cells.for.plotting, f = function(x,y) rbind(x,y))
selected.cells.for.plotting$Pathways <- rep(pathway.names, times = num.of.cells)
selected.cells.for.plotting <- selected.cells.for.plotting %>%
  select(-Can.be.used) %>%
  left_join(., pathway.genes.expression, by = c("Cells", "Pathways"))
  
# plot
p <- ggplot() +
  geom_boxplot(data = pathway.genes.expression, mapping = aes(x = Pathways, y = log10(Expression))) +
  geom_point(data = selected.cells.for.plotting, 
               mapping = aes(x = factor(Pathways), y = log10(Expression),
                             colour = Cells)) +
  xlab("Expression of pathway marker genes") +
  theme(axis.text.x = element_text(angle=45),
        panel.background = element_rect(colour = "black", fill = "white"))

p

```


```{r}

# the followings are for visualization
# add the filtered pathways back to the ccle.pathways
filtered.reactomes <- apply(essential, 1, filter.essential.genes, retain.percentile = c(0.2, 1))
names(filtered.reactomes) <- essential$Pathway

filtered.ccle.pathways <- ccle.pathways
filtered.ccle.pathways[1:11] <- filtered.reactomes

# remove the columns containing Ensembl IDs and gene names, so that I can do calculations
filtered.ccle.pathways <- lapply(filtered.ccle.pathways, FUN = select, 3:1078)

# calculate the sums of expression of pathway component in each cell lines
sum.gene.expression <- lapply(filtered.ccle.pathways, function(x) data.frame(Sums = colSums(x)))


# this pretty much done with the dataframe, so I can move on to selecting the cell lines
# as well as data visualization

# this is new to me! So I can save the list, and have a break point to clean up the rams!
save(sum.gene.expression, file = "sum_of_expression.RData")
```

```{r loading saved R data, echo=FALSE}
load("sum_of_expression.RData")
```

```{r calculate the quantile of each cell line with the pathway}

# I originally gave Shao-En a table containing a "+" for cell lines that have a high enough 
# expression of the pathway components. However, there is no information about the other
# pathways. To solve this, I want to produce another table containing the quantile to show
# where the particular cell line is sit in.

# the following function basically produced a list containing the quantiles of each pathway
# Then I just put the quantile in using if ... else statments. 
# This is not beautiful and very stupid!!!
add.quantile <- function(test) {
  quantile.in.pathway <- quantile(test[,1])
  test[,2] <- NA
  for (i in 1:nrow(test)) {
    if (test[i, 1] < quantile.in.pathway[[2]]) {
      test[i, 2] <- "< 25"
    } else if (test[i, 1] < quantile.in.pathway[[3]]) {
      test[i, 2] <- "< 50"
    } else if (test[i, 1] < quantile.in.pathway[[4]]) {
      test[i, 2] <- "< 75"
    } else {
      test[i, 2] <- "> 75"
    }
    colnames(test)[2] <- "Quantile"
  }
  return(test)
}

sum.gene.expression <- lapply(sum.gene.expression, add.quantile)

# change the name of the quantile columns
for (i in 1:21) {
  colnames(sum.gene.expression[[i]])[2] <- str_c("Quantile_", names(sum.gene.expression[i]))
  colnames(sum.gene.expression[[i]])[1] <- str_c("Sum_", names(sum.gene.expression[i]))
  # extract the cell names from row.names
  sum.gene.expression[[i]]$Cells <- row.names(sum.gene.expression[[i]])
}

# combine all of the dfs into 1 using reduce()
cell.pathway.sum.quantile <- reduce(sum.gene.expression, 
                                function(df1, df2) left_join(df1, df2, by = "Cells"))
# move the cell names to the 1st column and remove the columns containing the sum of expression
cell.pathway.quantile <- select(cell.pathway.sum.quantile, 3, contains("Quantile"))

# change to long form to help matching to the selected cell lines later
# also correct the pathway names in the pathway column, all of them contain "Quantile_" now. 
cell.pathway.quantile <- cell.pathway.quantile %>%
  gather(key = "Pathways", value = "Quantiles", -Cells) %>%
  separate(col = Pathways, into = c("crap", "Pathways"), sep = "e_") %>%
  select(-crap)

# also make another df containing the sum of component expression instead of just the quantile
cell.pathway.sum <- select(cell.pathway.sum.quantile, 3, contains("Sum")) %>%
  gather(key = "Pathways", value = "Sum.of.expression", -Cells) %>%
  separate(col = Pathways, into = c("crap", "Pathways"), sep = "m_") %>%
  select(-crap)

```

```{r calculate cut off and pick cell lines, echo=FALSE}
# I want to pick the cut off base on the boxplot, 
# the whisker of the boxplot is 75 % quantile + 1.5 * IQR

# write a function to calculate the cut off for each pathway for picking the cells
cal.cut.off <- function(x) {
  # there are some imputed values and I know that it should be the min, so remove them
  fake.number <- min(x[1][,1])
  x[1][,1] <- ifelse(x[1][,1] == fake.number, NA, x[1][,1])
  cut.off <- quantile(x[1][,1], 0.75, na.rm = TRUE) + 1.5 * IQR(x[1][,1], na.rm = TRUE)
}

# make the list containing the cut off values 
cut.off.list <- lapply(sum.gene.expression, FUN = cal.cut.off)
# turn the list into a df
cut.off.list <- data.frame(Cut.off = unlist(cut.off.list))

########
# picking the cells here
########

# at this point, the dfs contain 2 columns, 
# the sum of component expression and the quantile that the cell lines are sitting in each pathway

# make a list of df to hold the cells
cells.list <- list()

# the for loop to get the cells. Have to use two lists for this
# 1. the list containing the sum of gene expressions
# 2. the list containing the cut off 
for (i in 1:21) {
  cells.list[[i]] <- sum.gene.expression[[i]][sum.gene.expression[[i]][,1] >= 
                                                cut.off.list[i, 1], ,
                                              drop = FALSE]
  # add a column containing the pathway names, just to preserve it for later
  cells.list[[i]][1:nrow(cells.list[[i]]), 3] <- "+"
  colnames(cells.list[[i]])[3] <- names(sum.gene.expression[i])
  
  # the cell line names are the row names now, I want to convert it into a column
  cells.list[[i]][1:nrow(cells.list[[i]]), 4] <- row.names(cells.list[[i]])
  cells.list[[i]] <- select(cells.list[[i]], Cells = 4, 3)
}

# reduce repeat the function in a sequential manner, until it finished the list, I think
# the input is a list, then I added the function with 2 inputs and run full_join()
cells.list <- reduce(cells.list, function(df1, df2) full_join(df1, df2, by = "Cells"))

# convert to long form to match with quantile data
cells.list <- cells.list %>%
  gather(key = "Pathways", value = "Picked", -Cells)

# match the picked cell with the quantile information, added a column
cells.list.quantile <- left_join(cells.list, cell.pathway.quantile, by = c("Cells", "Pathways"))

# fill the NAs in the picked cells column with the quantile number, then remove the information, turn back to wide format
cells.list.quantile <- cells.list.quantile %>%
  mutate(Picked = ifelse(is.na(cells.list.quantile$Picked), 
                         cells.list.quantile$Quantiles, 
                         cells.list.quantile$Picked)) %>%
  select(-Quantiles) %>%
  spread(key = Pathways, value = Picked)

# use str_split, because I can choose how many items the original string will be splitting into
temp <- str_split(string = cells.list.quantile$Cells, pattern = "_", n = 2)
temp <- data.frame(matrix(unlist(temp), ncol = 2, byrow = TRUE))
colnames(temp)[1:2] <- c("Cell.lines", "Tissues")
cells.list.quantile <- cbind(temp, cells.list.quantile[, 2:22])

#write.table(cells.list, "Picked_cells.txt", sep = "\t",
#            row.names = FALSE, quote = FALSE, append = FALSE)

##############################
# match picked cells with sum of expression data. SE wants to try clustering
##############################

# match the picked cell with the quantile information, added a column
cells.list.sum <- left_join(cells.list, cell.pathway.sum, by = c("Cells", "Pathways"))

# fill the NAs in the picked cells column with the quantile number, then remove the information, turn back to wide format
cells.list.sum <- cells.list.sum %>%
  select(-Picked) %>%
  spread(key = Pathways, value = Sum.of.expression)

# use str_split, because I can choose how many items the original string will be splitting into
temp <- str_split(string = cells.list.sum$Cells, pattern = "_", n = 2)
temp <- data.frame(matrix(unlist(temp), ncol = 2, byrow = TRUE))
colnames(temp)[1:2] <- c("Cell.lines", "Tissues")
cells.list.sum <- cbind(temp, cells.list.sum[, 2:22])

#write.table(cells.list.sum, "Picked_cells_sum_expression.txt", sep = "\t",
#            row.names = FALSE, quote = FALSE, append = FALSE)

```

And there are 500 cell lines from 23 tissue types
```{r plotting cells data, echo=FALSE}

tissue.types <- ggplot(cells.list.sum) +
  geom_bar(mapping = aes(x = Tissues)) +
  theme(axis.text.x = element_text(angle = 60, hjust = 1),
        panel.background = element_rect(fill = "white", colour = "grey50")) +
  guides(fill=FALSE)

tissue.types

```

```{r %pathway in each tissue type, echo=FALSE}

# I want to see which the percentage of each pathway in each tissue type

# change the list into a long form
cells.list.long <- cells.list %>%
  separate(Cells, into = c("Cell.lines", "Tissues"), sep = "_", n = 2) %>%
  filter(!is.na(Picked))


# then get a count table for the cell lines, basically how many cell line is in each pathway in each tissue type
x <- data.frame(table(cells.list.long[, 2:3]))

# then group the data by tissue type and calculate the percentage of pathway
y <- group_by(x, Tissues) %>% mutate(Percent = Freq/sum(Freq) * 100)

# Clean up the table
z <- y %>% mutate(Percent = ifelse(Percent == 0, NA, Percent)) %>%
  select(-Freq) %>%
  spread(key = Pathways, value = Percent) 

# plot it out
percent_of_pathway <- ggplot(y) +
  geom_bar(mapping = aes(x = Tissues, y = Percent, fill = Pathways), stat = "identity") +
  theme(axis.text.x = element_text(angle = 60, hjust = 1),
        panel.background = element_rect(fill = "white")) +
  scale_fill_manual(values = colorRampPalette(brewer.pal(9, "Set1"))(23)) 

percent_of_pathway

```


Following is the example for how cell lines are picked based on their expression level of the pathway components.
```{r select cells and data visualisation, echo=FALSE}

# take EGF signaling out, I want to use it as an example to show the way we select cells
egf <- sum.gene.expression$Reactome.EGFR

# add a column just for the plotting
egf$xaxis <- 1:nrow(egf) 
egf$box.axis <- "EGF"

# calculate the cut off, which should be 75 % quantile + 1.5 x IQR
fake.value <- min(egf$Sum_Reactome.EGFR)
Sums <- egf$Sum_Reactome.EGFR
Sums <- ifelse(Sums == fake.value, NA, Sums)
cut.off <- quantile(Sums, 0.75, na.rm = TRUE) + 1.5 * IQR(Sums, na.rm = TRUE)
# then separate the data to 2 groups based on the cut off
egf$Picked <- egf$Sum_Reactome.EGFR >= cut.off

# I want to see if I can do a scatter plot with boxplot next to it, which require the ggpubr
scatter.plot <- ggscatter(egf, 
                          x = "xaxis", y = "Sum_Reactome.EGFR", 
                          color = "Picked", palette = c("Grey", "Red"))

# the boxplot 
box <- ggboxplot(egf, x = "box.axis", y = "Sum_Reactome.EGFR", 
                 alpha = 0.5, 
                 fill = "grey") + clean_theme()

combine.plot <- ggarrange(scatter.plot, box,
          ncol = 2, align = "h",
          widths = c(9, 1), heights = c(1,1),
          common.legend = TRUE)

combine.plot

```

To make a heatmap to visualize the picks

```{r}

# just so that I don't have to go back up to find the name
cell.pathway.sum <- cell.pathway.sum # this hold the cells with the sum of expression

# spread the cells 
for.heatmap <- cell.pathway.sum %>%
  mutate(Sum.of.expression = log10(Sum.of.expression)) %>%
  filter(str_detect(Pathways, "Reactome")) %>% 
  separate(Pathways, into = c("meh", "Pathways")) %>%
  select(-meh) %>%
  spread(key = Pathways, value = Sum.of.expression)

# write a function to remove the lowest number, scale and then impute with 0

scale.impute <- function(x) {
  x <- ifelse(x == min(x), NA, x)
  scale.x <- scale(x)
  scale.x <- ifelse(is.na(scale.x), 0, scale.x)
}

for.heatmap[, -1] <- apply(as.matrix(for.heatmap[, -1]), 2, scale.impute)

heatmap.2(t(for.heatmap[, -1]), 
          trace = "none",
          col = rev(redblue(30)))

```

