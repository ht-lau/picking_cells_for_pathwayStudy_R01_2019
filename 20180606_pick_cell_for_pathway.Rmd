---
title: "Picking CCLE cell lines for pathway analysis"
output: 
---

This is for the July R01 application. The idea is to use kinome beads on CCLE cell lines to study different pathways. Shao-En was questioned how to pick the cell lines in the previous application. So he want to see if there is way to pick the cells based on pathway components expression level. 

Let me try.

The data was downloaded by Shao-En from CCLE. I think they are all read counts and have to be normalized before doing any analysis.

The normalization will be done using DESeq2. 
I originally wanted to use TPM for normalization, but the formula is not very clear to me... so to be safe, I will just use DESeq2.

```{r packages, message=FALSE}
library(tidyverse)
library(ggthemes)
library(DESeq2)
library(robustbase)
```

```{r data import and normalization using DESeq2}

# import the raw count data, there are two rows of crap, so I will have to skip it
raw.counts <- read.delim("CCLE_DepMap_18Q2_RNAseq_reads_20180502.gct",
                         header = TRUE, stringsAsFactors = FALSE,
                         skip = 2)

### DESeq2 require a matrix with gene name as row names,                                                    ###
### then another matrix for annotation containing the column names (which is cell lines in this case)       ###

# make the coutn data matrix
count.data <- as.matrix(raw.counts[, 3:1078])
row.names(count.data) <- raw.counts$Name         # the row names are the Ensembl IDs

# annotation matrix, this contain a single column named condition, which is the name of the cell lines
coldata <- as.matrix(data.frame(condition = names(raw.counts[, 3:1078]))) 
row.names(coldata) <- names(raw.counts[, 3:1078])   # also make the cell lines as the col.names

# create the DESeq object
dds <- DESeqDataSetFromMatrix(countData = count.data,
                              colData = coldata,
                              design = ~condition) # design is just the condition in this case

# then create the normalization factor using estimateSizeFactors()
dds <- estimateSizeFactors(dds)

# retrieve the normalized count using counts(, normalized = TRUE)
nor.CCLE <- raw.counts[, 1:2]
colnames(nor.CCLE) <- c("Ensembl", "Gene.names")
nor.CCLE <- cbind(nor.CCLE, data.frame(counts(dds, normalized = TRUE), stringsAsFactors = FALSE), row.names = NULL)

# export the normalized data
write.table(nor.CCLE, "Normalized_CCLE_RNAseq.txt", sep = "\t",
            quote = FALSE, append = FALSE, row.names = FALSE)
```

```{r import the genes involved regulations according to Reactome}

### signal transduction -> by RTK -> EGFR ###
egfr <- read.delim("by_EGFR.tsv", header = TRUE, stringsAsFactors = FALSE)
egfr <- egfr %>% separate(MoleculeName, into = c("Molecule" , "Gene.name"), sep = " ") %>%
  filter(MoleculeType == "Proteins")
egfr <- egfr$Gene.name[!duplicated(egfr$Gene.name)]

### response to stimulations -> stress -> hypoxia
hypoxia <- read.delim("by_hypoxia.tsv", header = TRUE, stringsAsFactors = FALSE)
hypoxia <- hypoxia %>% separate(MoleculeName, into = c("Molecule" , "Gene.name"), sep = " ") %>%
  filter(MoleculeType == "Proteins")
hypoxia <- hypoxia$Gene.name[!duplicated(hypoxia$Gene.name)]
```

```{r imported the normalized gene expression saved in earlier part of this R script}
nor.CCLE <- read.delim("Normalized_CCLE_RNAseq.txt", header = TRUE, stringsAsFactors = FALSE)
```

To see what is the best way of picking the cell lines to study, I want to try Rank sum of the expression, mean expresssion, median and the sum of expression of all genes involved in a particular pathway / stimulation. 
```{r try ranking the pathway components}

##################################################################
##################### the following parts work with EGFR 
##################################################################

### let's try using rank to see whether it is a good way to differentiate the cell lines ###

# copy the df 1st
rank.expression <- nor.CCLE

# then rank order all of the gene expressions, producing a matrix
rank.expression <- apply(rank.expression[, 3:1078], 2, 
                         FUN = rank, ties.method = "min") # rank will order ascendingly, 
                                                          # so lower expression get a smaller rank number
                                                          # ties.method = "min" put the ties to a smaller number

# add the Ensembl IDs and gene names back to the matrix, produce a df
rank.expression <- cbind(nor.CCLE[, 1:2], rank.expression)

# then select genes that are only in the egfr pathway
egfr.rank <- rank.expression[rank.expression$Gene.names %in% egfr, ]

# add up the rank of the egfr pathway components 
egfr.matrix <- data.frame(Ensembl = rank.expression$Ensembl, stringsAsFactors = FALSE)
egfr.matrix <- data.frame(Rank.sum = colSums(egfr.rank[, 3:1078]), stringsAsFactors = FALSE)

```


```{r making the medians, means and sums of expression of the EGFR components}

# make a df containig the normalized expression of egfr components
egfr.ccle <- nor.CCLE[nor.CCLE$Gene.names %in% egfr, ]

#####################
### median ##########
#####################

# calculate the medians and add to the egfr.matrix
egfr.matrix$Median <- robustbase::colMedians(as.matrix(egfr.ccle[, 3:1078]))

#####################
### mean ##########
#####################

egfr.matrix$Mean <- colMeans(as.matrix(egfr.ccle[, 3:1078]))

#####################
### median ##########
#####################

egfr.matrix$Sum <- colSums(as.matrix(egfr.ccle[, 3:1078]))

```

```{r clean up and visualize}

egfr.matrix$Cell.lines <- row.names(egfr.matrix)
egfr.matrix.long <- egfr.matrix %>% gather(key = "Methods", value = "Expressions", 1:4)

ggplot(egfr.matrix.long) +
  geom_point(mapping = aes(x = Cell.lines, y = Expressions)) +
  facet_wrap(~ Methods, scales = "free_y")

# boxplot
ggplot(egfr.matrix.long) +
  geom_boxplot(mapping = aes(x = Methods, y = Expressions))

# get the outliner value, this is the max value of the whisker
max.whisk <- quantile(egfr.matrix$Sum, 0.75) + 1.5 * IQR(egfr.matrix$Sum)

# get the cell lines in the outlying region
Cells <- data.frame(Cell.lines = egfr.matrix$Cell.lines[egfr.matrix$Sum >= max.whisk])
Cells$Signal <- "EGFR"
```

The plots suggested that mean and sum are the best way in differentiating the cell lines. To make sure, I want to try another signaling pathway. Picked hypoxia because it is not a endogenous growth factor

```{r try ranking the pathway components}

##################################################################
##################### the following parts work with hypoxia 
##################################################################

# select genes that are only in the hypoxia pathway
hypoxia.rank <- rank.expression[rank.expression$Gene.names %in% hypoxia, ]

# add up the rank of the hypoxia pathway components 
hypoxia.matrix <- data.frame(Ensembl = rank.expression$Ensembl, stringsAsFactors = FALSE)
hypoxia.matrix <- data.frame(Rank.sum = colSums(hypoxia.rank[, 3:1078]), stringsAsFactors = FALSE)

```


```{r making the medians, means and sums of expression of the hypoxia components}

# make a df containig the normalized expression of hypoxia components
hypoxia.ccle <- nor.CCLE[nor.CCLE$Gene.names %in% hypoxia, ]

#####################
### median ##########
#####################

# calculate the medians and add to the hypoxia.matrix
hypoxia.matrix$Median <- robustbase::colMedians(as.matrix(hypoxia.ccle[, 3:1078]))

#####################
### mean ##########
#####################

hypoxia.matrix$Mean <- colMeans(as.matrix(hypoxia.ccle[, 3:1078]))

#####################
### median ##########
#####################

hypoxia.matrix$Sum <- colSums(as.matrix(hypoxia.ccle[, 3:1078]))

```

```{r clean up and visualize}

hypoxia.matrix$Cell.lines <- row.names(hypoxia.matrix)
hypoxia.matrix.long <- hypoxia.matrix %>% gather(key = "Methods", value = "Expressions", 1:4)

ggplot(hypoxia.matrix.long) +
  geom_point(mapping = aes(x = Cell.lines, y = Expressions)) +
  facet_wrap(~ Methods, scales = "free_y")

# boxplot
ggplot(hypoxia.matrix.long) +
  geom_boxplot(mapping = aes(x = Methods, y = Expressions))

# get the outliner value, this is the max value of the whisker
max.whisk <- quantile(hypoxia.matrix$Sum, 0.75) + 1.5 * IQR(hypoxia.matrix$Sum)

# get the cell lines in the outlying region
Cells.hypoxia <- data.frame(Cell.lines = hypoxia.matrix$Cell.lines[hypoxia.matrix$Sum >= max.whisk])
Cells.hypoxia$Signal <- "hypoxia"

Cells <- full_join(Cells, Cells.hypoxia, by = "Cell.lines")

```
